CMPS 111 - 01
Seongwoo Choi
Week 10 Notes


DEvice Controllers
I/O devices have components
- Mechanical Components

Direct Memory Access (DMA)
I/O software: goals
-Device independence
-Uniform naming
-Error handling
-Synchronous vs. asynchronous transfers
-Buffering
-Sharable vs dedicated devices

Programmed I/O
Code for programmed I/O

I/O using DMA
code run by system calls

Layers of I/O software

Interrupt handlers
-Interrupt handlers are best hidden

What happens on an interrupt

Device drivers
-Device drivers go between

Device-independent I/O software
- it provides common "library"

What happens where on an i/o request?
Make I/O calls format I/O; spooling
Naming, protection
blocking/ buffering/ allocation

Disk Drive Structure
-Data stored on surfaces
-Data in concentric tracks
-Data read and written by heads
--> Actual or moves heads
--> Heads move in unison

Disk drive specifies

Sector layout on disk
-> sector

Disk "addressing"
-Millions of sectors on the disk must be labeled.
Sector layout on disk

When good disks go bad...

Building a better "disk"
-Problem: CPU performance has been increasing exponentially but disk performance has not.

Calculating parity
-Goal: keep extra information to recover from device failure

RAIDs, RAIDs, and more RAIDs

CD/DVD-ROM recording
-DVD-ROM has data in a spiral
-> Hard drives have concentric circles of data

What's in a disk request?
-Time required to read or write a disk block determined by 3 factors
-> Seek time - typically

Disk request scheduling

Disk scheduling algorithms
Schedule disk request

First-Come-First served

Shortest Seek Time First
Starvation

SCAN (elevator algorithm)
Disk arm starts at one end of the disk and moves towards the other end, servicing requests as it goes
->REverses direction when it gets to end of the disk
-> also known

C-SCAN
Identical to SCAN, except head returns to cylinder 0 when it reaches

C-LOOK

Picking a disk scheduling algorithm
SSTF is easy to...

Flash memory (and SSDs)
-Compared to disk, flash is
->Faster (shortest access time but lower bandwidth)
->More expensive
->More reliable (devices)
->Less reliable (sectors)

Compared to DRAM, flash is

Writing to flash memory
cannot overwrite page in place

Is there a better to manage flash?
Log-structured data storage works well on flash

Handling flash in the OS
Treat it like a disk?
->Flash is written in blocks, just like a disk

Need to be careful about wearing out flash

Clock Hardware
-Crystal oscillator with fixed frequency (only when computer is on)
->Typically used to time short intervals (~1 second)
->May be used to correct time-of-day clock

Keeping time
-Checking time via the web

Using timers in software

Where does the power go?

REducing at full clock speed
-Running at full clock speed
->Jobs finish quickly
->High energy consumption: pro..


Security
Security environment: threats

What kinds of intruders are there?
-Casual prying by nintechnical users
->curiosity

Accidents cause problems, too
-Acts of god
--Fire

Protection
Security is about mechanism
->How to enforce policies
->Policies largely independent of mechanism

Protection is about specifying policies

Protection domains
Three protection domains
-Each list objects

Protection Matrix
Each domain has a row in the matrix

Domains: objects in the protection matrix
Specify permitted operations on domains in the matrix

Representing the protection matrix
Need to find an efficient representation

Access control list
-Each object has a list attached to it
-List has
->Protection domain
-->user name
-->group of users
-->others
-Access rights

Access control lists in the real world
-Unix file system
--Access list for each file has exactly three domains on it
-->User (owner)
-->Group: set of

Capabilities
Each process has a capability list
List has one entry per object the process can access
->Object name
->Object permission
Objects not listed are not accessible

How are these secured?
->Kept in kernel
->Cryptographically secured

Capability replication problem

Cryptographically protected capability

Rights include generic rights (read, write, execute) and
-Copy capability
-Copy object
-Remove capability
-Destroy object

Server

Protecting the access matrix: summary
Os must ensure that the access matrix

Bell-La Padula X

Covert Channels
Circumvent security model by using more sublt ways of passing information

Can't directly send data against system's wishes
Send data using "side effects"
-Allocating resources
-Using the CPU
-Locking a file
-Making small changes in legal data exchange
Very difficult to plug leaks in covert channels

Covert channel using file locking
-Exchange information using file locking
-Assume n+1 files accessible to both A and B
-A sends information by
--Locking files 0...n-1 according to an n-bit quantity to be conveyed to B.

Locking file n to indicagte that information available
B gets information by
-Reading the lock state of files 0 ... n+1
-Unlocking file n to show that the information was received

May not even nned access to the files (on some systems) to detect lock status

Steganography
-Hide information in other data
-Picture on right has text of 5 shakespeare plays
-Encrypted, inserted into low order bits of color values

Cryptography
-Goal: keep information from those who are not supposed to see it
-Do this by "scrambling" the data

Use a well-known algorithm to scramble data
--Algorithm has two inputs: data and key
--key is known only to "authorized" users
Relying upon the secrecy of the algorithm is a very bad idea

Cracking codes is very difficult, sneakers and swordfish and other movies notwithstanding

Cryptography basics
Algorithms (E,D) are widely

Secret-key encryption
Also called sysmmetric-key encryption
Monophabetc sybstitution
->Each letter replaced by different letter

Modern encryption algorithms
Data encryption standard (DES)
-Uses 56-bit keys
-Same key is used to encrypt and decrypt
-Keys used to be difficult to guess
-->Needed to try 2^56 different keys, on average
-->modern computers can try millions of keys per second with special hardware.
-->For $250K, EFF built a machine that broke DES quickly

Current algorithms (AES, Blowfish) use at least 128 bit keys
-->Adding one bit to the key makes it twice as hard to guess
--> must try 2^127 keys, on average, to find the right one.

Unbreakable code
Threre is such a thing as an unbreakable code: one time pad
-Use a truly random key as long as the message to be encoded
-XOR the message with the key a bit at a time

Code is unbreakable because
-Key could be anything
-Without knowing key, message could be anything with the correct number of bits in it
Difficult: distributing key is as hard as distributing message
--may be easier because of timing
Difficult: generating truly random bits

Public-key cryptography
Instead of using a single shared secret, keys come in pairs
--One key of each pair distributed widely
--One key of each pair kept secret
--keys are inverses of one another, but not identical
--Encryption and decryption are the same algorithm, so E(KU, E(KR,M) = E(KR,E(KU,M) = M.

Typically used for
--Encrypting small amounts of data
--Establishing a shared key between two users who might not know each other

Currently, the most popular method involves primes and expenetiation

RSA algorithm for public key encryption
Private, public key pair consists of KR = (d,n), KU = (en)
- n = pxq (p and q are large prime numbers)
- e is a randomly chosen integer with GCD
- d is an integer such that (exd) = 1(mod(p-1)x(q-1))

P and q are not published, and can be used by anyone to send a message to the private key's owner.

Encryption and decryption are the same algorithm
E(KU, M) = m e MOD n (similar for KR)
Methods exist for doing the above calculate quickly but..
Exponentiation is still very slow.
Public key encryption not usually done with larger messages one way function

Digital signature
-Digital signature computed by
-->Applying one-way hash function to original document
-->Encrypting result with sender's private key

-Receiver can verify by
-->Applying one-way hash function to received document
-->Decrypting signature using...

Pretty good privacy(PGP)
Uses public key encryption
->Facilities key distribution 
->Allows messages to be sent encryted to a person (encrypt with person's public key)
->Allows person to send message that must hve come from her (encrypt with person's private key)

Problem: public key encryption very slow
Solution: use public key encryption

User authentication

Authentication using passwords

Successful login lets the user in 
If things don't go so well
Login rejected after name entered 
Login rejected after name and incorrect password entered

Don't notify 
Dealing with passwords
Passwords should be memorable
